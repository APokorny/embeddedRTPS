diff --git a/test/performance/LatencyTestPublisher.cpp b/test/performance/LatencyTestPublisher.cpp
index a6bcd6f..9fe4250 100644
--- a/test/performance/LatencyTestPublisher.cpp
+++ b/test/performance/LatencyTestPublisher.cpp
@@ -578,6 +578,27 @@ bool LatencyTestPublisher::test(uint32_t datasize)
     analyzeTimes(datasize);
     printStat(m_stats.back());
 
+		std::stringstream ss;
+#ifdef TEST_RT
+    ss << "RT_";
+#endif
+	  ss << "perf_LatencyTest_";
+    ss << datasize;
+    if(reliable_)
+      ss << "_reliable";
+    ss << "_raw.csv";
+
+    std::ofstream outfile_raw;
+    outfile_raw.open(ss.str());
+
+    for(std::vector<std::chrono::duration<double, std::micro>>::iterator tit = times_raw_.begin(); tit != times_raw_.end(); ++tit)
+    {
+        outfile_raw << (*tit).count() << std::endl;
+    }
+
+		outfile_raw.flush();
+		outfile_raw.close();
+
     delete(mp_latency_in);
     delete(mp_latency_out);
 
@@ -586,6 +607,8 @@ bool LatencyTestPublisher::test(uint32_t datasize)
 
 void LatencyTestPublisher::analyzeTimes(uint32_t datasize)
 {
+
+    times_.erase(times_.begin());
     TimeStats TS;
     TS.nbytes = datasize+4;
     TS.received = n_received;
@@ -601,6 +624,7 @@ void LatencyTestPublisher::analyzeTimes(uint32_t datasize)
     auxstdev = sqrt(auxstdev / times_.size());
     TS.stdev = static_cast<double>(round(auxstdev));
 
+    times_raw_ = times_;
     std::sort(times_.begin(), times_.end());
     size_t elem = 0;
 
diff --git a/test/performance/LatencyTestPublisher.h b/test/performance/LatencyTestPublisher.h
index 8e92ae2..f41850c 100644
--- a/test/performance/LatencyTestPublisher.h
+++ b/test/performance/LatencyTestPublisher.h
@@ -20,6 +20,8 @@
 #ifndef LATENCYPUBLISHER_H_
 #define LATENCYPUBLISHER_H_
 
+#define TEST_RT
+
 #include <asio.hpp>
 
 #include "LatencyTestTypes.h"
@@ -55,6 +57,7 @@ class LatencyTestPublisher {
         unsigned int n_samples;
         eprosima::fastrtps::SampleInfo_t m_sampleinfo;
         std::vector<std::chrono::duration<double, std::micro>> times_;
+        std::vector<std::chrono::duration<double, std::micro>> times_raw_;
         std::vector<TimeStats> m_stats;
         std::mutex mutex_;
         int disc_count_;
diff --git a/test/performance/main_LatencyTest.cpp b/test/performance/main_LatencyTest.cpp
index 0d20b12..1ee3c7e 100644
--- a/test/performance/main_LatencyTest.cpp
+++ b/test/performance/main_LatencyTest.cpp
@@ -24,6 +24,13 @@
 #include <bitset>
 #include <cstdint>
 
+#include <limits.h>
+#include <pthread.h>
+#include <sched.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <sys/mman.h>
+
 #include <fastrtps/log/Log.h>
 #include <fastrtps/Domain.h>
 #include <fastrtps/fastrtps_dll.h>
@@ -126,7 +133,10 @@ const option::Descriptor usage[] = {
 
 const int c_n_samples = 10000;
 
-int main(int argc, char** argv){
+
+
+
+int main_wrapped(int argc, char** argv){
 
     int columns;
 
@@ -141,7 +151,7 @@ int main(int argc, char** argv){
         columns = 80;
     }
 #else
-    columns = getenv("COLUMNS")? atoi(getenv("COLUMNS")) : 80;
+    columns = 80;
 #endif
 
     bool pub_sub = false;
@@ -177,9 +187,11 @@ int main(int argc, char** argv){
     }
 
     argc-=(argc>0); argv+=(argc>0); // skip pub/sub argument
-    option::Stats stats(usage, argc, argv);
+
+		option::Stats stats(usage, argc, argv);
     std::vector<option::Option> options(stats.options_max);
     std::vector<option::Option> buffer(stats.buffer_max);
+
     option::Parser parse(usage, argc, argv, &options[0], &buffer[0]);
 
     if (parse.error())
@@ -337,6 +349,92 @@ int main(int argc, char** argv){
     return 0;
 }
 
+typedef struct arg_t{
+	int argc;
+  char** argv;
+} arg_t;
+
+void* thread_func(void* data){
+  std::cout << "RT Thread start" << std::endl;
+	arg_t* arg = (arg_t*) data;
+  main_wrapped(arg->argc, arg->argv);
+
+  return 0;
+}
+
+int main(int argc, char** argv){
+
+#ifndef TEST_RT
+				main_wrapped(argc, argv);
+				return 0;
+#endif
+        std::cout << "Running test with real-time priority" << std::endl;
+        struct sched_param param;
+        pthread_attr_t attr;
+        pthread_t thread;
+        int ret;
+
+        // Lock memory
+        if(mlockall(MCL_CURRENT|MCL_FUTURE) == -1) {
+                printf("mlockall failed: %m\n");
+                exit(-2);
+        }
+
+        // Initialize pthread attributes (default values)
+        ret = pthread_attr_init(&attr);
+        if (ret) {
+                printf("init pthread attributes failed\n");
+                goto out;
+        }
+
+        // Set a specific stack size
+        ret = pthread_attr_setstacksize(&attr, 1e+7);
+        if (ret) {
+            printf("pthread setstacksize failed\n");
+            goto out;
+        }
+
+        // Set scheduler policy and priority of pthread
+        ret = pthread_attr_setschedpolicy(&attr, SCHED_FIFO);
+        if (ret) {
+                printf("pthread setschedpolicy failed\n");
+                goto out;
+        }
+        param.sched_priority = 98;
+        ret = pthread_attr_setschedparam(&attr, &param);
+        if (ret) {
+                printf("pthread setschedparam failed\n");
+                goto out;
+        }
+
+        // Use scheduling parameters of attr
+        ret = pthread_attr_setinheritsched(&attr, PTHREAD_EXPLICIT_SCHED);
+        if (ret) {
+                printf("pthread setinheritsched failed\n");
+                goto out;
+        }
+
+        arg_t arg;
+        arg.argc = argc;
+        arg.argv = argv;
+
+        /* Create a pthread with specified attributes */
+        ret = pthread_create(&thread, &attr, thread_func, (void*)&arg);
+        if (ret) {
+                printf("create pthread failed\n");
+                goto out;
+        }
+        /* Join the thread and wait until it is done */
+        ret = pthread_join(thread, NULL);
+        if (ret)
+                printf("join pthread failed: %m\n");
+
+out:
+        return ret;
+
+}
+
+
 #if defined(_MSC_VER)
 #pragma warning (pop)
 #endif
